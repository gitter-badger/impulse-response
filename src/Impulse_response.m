pkg load optim
pkg load signal
addpath("../loaders:../lib");
close all;
clear all;

rad2deg = 180/pi;

# path to CSV files
fflush (stdout);
choice = input("load example dataset? (Y/n):", "s");
if length(choice) == 0 || choice == 'Y' || choice == 'y'
%  basePath = "/home/markw/gdrive/flightlogs/S250AQ/2016-12-05/log002/"
%  startTime = 148;
%  endTime = 160;
  #basePath = "/home/markw/gdrive/flightlogs/S250_pixracer/2016-08-18/sess001/log3/"
  basePath = "/home/markw/Dropbox/Octave_sources/PX4/ulogs/AquaQuad/2016-09-17/"
  startTime = 130;
  endTime = 172;
else
  basePath = "";
endif

# set default run parameters
# desired uniform sample rate in Hz; should be less than average sample rate
sampRate = 100
# set to true when start/endTime are correct
rangeSelected = 0;
# length in seconds of impulse response plot
impLen = 1.5

if strcmp(basePath, "")
  basePath = [uigetdir(basePath) "/"];
endif

# CSV files generated by u2log2csv.py are prefixed by "logname_"
files = readdir(basePath);
for i = [1:size(files)(1)]
  r = cell2mat(strfind(files(i), "sensor_combined"));
  if (r > 0) 
    prefix = cell2mat(files(i))(1:r-1)
    break 
  endif
endfor

# load the measured rates, rate setpoints and rate controls (actuator input)
[g0t, gyro0] = loadSensor_xyz(prefix, 0, basePath);
[s0t, setpoint0] = loadVrates_xyz(prefix, 0, basePath);
[c0t, control0] = loadControlGroup0_xyz(prefix, 0, basePath);

# load the attitude quaternions and attitude setpoints
[q0t, q0] = loadAttitude_quat(prefix, 0, basePath);
[as0t, att_sp0] = loadAttSP_xyz(prefix, 0, basePath);

nsamples = size(gyro0)(1);

# find timespan of gyro data
if (!exist('startTime') | !exist('endTime'))
  startTime = g0t(1)
  endTime = g0t(end)
  sigRange = [1:nsamples];
else
  # find index span of gyro data
  startOffset = 1;
  while (g0t(startOffset) < startTime) startOffset++; endwhile
  endOffset = startOffset;
  while (g0t(endOffset) < endTime) endOffset++; endwhile
  sigRange = [startOffset:endOffset];
endif

figNum = 1;
figure(figNum++, "Position", [1,200,1200,320]);
subplot(2,1,1);
# ticks, rollRate, pitchRate
plot(g0t, gyro0(:,1), "-b", g0t, gyro0(:,2), "-r");
axis("tight"); title("raw roll and pitch rate data extents");
xlabel("seconds");
grid("on"); grid("minor");

while (true)
  subplot(2,1,2);
  plot(g0t(sigRange), gyro0(sigRange,1), "-b", g0t(sigRange), gyro0(sigRange,2), "-r");
  axis("tight"); title("raw roll and pitch rate data subset");
  xlabel("seconds");
  grid("on"); grid("minor");

  newStart = input("enter new startTime (0 if done): ");
  if (newStart == 0) 
    break; 
  else
    startTime = newStart;
  endif;
  endTime = input("new endTime: ");

  # find index span of gyro data
  startOffset = 1;
  while (g0t(startOffset) < startTime) startOffset++; endwhile
  endOffset = startOffset;
  while (g0t(endOffset) < endTime) endOffset++; endwhile
  sigRange = [startOffset:endOffset];
endwhile

# resample to uniform rate, over the time range [startTime, endTime]
[g0tu, gyro0u] = resample2(startTime, endTime, g0t, gyro0, sampRate);
[s0tu, setpoint0u] = resample2(startTime, endTime, s0t, setpoint0, sampRate);
[c0tu, control0u] = resample2(startTime, endTime, c0t, control0, sampRate);

# avoid discontinuites in attitude_setpoint data by limiting range to selected segment
startOffset = 1;
while (as0t(startOffset) < startTime) startOffset++; endwhile
endOffset = startOffset;
while (as0t(endOffset) < endTime) endOffset++; endwhile
# need an extra sample at each end of the segment for cubic Hermite interpolation
attspRange = [startOffset-1:endOffset+1];

[q0tu, q0u] = resample2(startTime, endTime, q0t, q0, sampRate);
[as0tu, att_sp0u] = resample2(startTime, endTime, as0t(attspRange), att_sp0(attspRange,:), sampRate);

# convert quaternion to Euler angles
[roll0u, pitch0u, yaw0u] = quat2euler(q0u);

# take derivative of rates
gyroDot0u = ddt(gyro0u);

nsamples = size(gyro0u)(1);
sigRange = [1:nsamples];

rollRateSig = gyro0u(sigRange,1);
rollAccelSig = gyroDot0u(sigRange,1);
rollSetpoint = setpoint0u(sigRange,1);
rollControl = control0u(sigRange,1);
rollAttSP = att_sp0u(sigRange,1);
rollAngleSig = roll0u(sigRange);

pitchRateSig = gyro0u(sigRange,2);
pitchAccelSig = gyroDot0u(sigRange,2);
pitchSetpoint = setpoint0u(sigRange,2);
pitchControl = control0u(sigRange,2);
pitchAttSP = att_sp0u(sigRange,2);
pitchAngleSig = pitch0u(sigRange);

# sample interval in seconds
sampInt = 1 / sampRate;

# these globals are used by functions hstarRoll/PitchStim which are invoked
# by function leasqr()
# the "signal" is modeled as h * groll/pitchStim and leasqr finds the parameters
# p1,p2,p3 which result in the best match to roll/pitchStim
global gfitrng;
gfitrng = [0:sampInt:impLen]';

TFopt = input("Estimate closed loop tilt(2), rate(1) or accel(0) response:");

global grollStim;
global gpitchStim;
if TFopt==2
  label = "Angle";
  fprefix = "tilt_";
  grollStim = rollAttSP(:);
  rollSig = rollAngleSig;
  gpitchStim = pitchAttSP(:);
  pitchSig = pitchAngleSig;
elseif TFopt==1
  label = "Angular rate";
  fprefix = "rate_";
  grollStim = rollSetpoint(:);
  rollSig = rollRateSig;
  gpitchStim = pitchSetpoint(:);
  pitchSig = pitchRateSig;
else % accel response
  label = "Angular accel";
  fprefix = "accel_";
  grollStim = rollControl(:);
  rollSig = rollAccelSig;
  gpitchStim = pitchControl(:);
  pitchSig = pitchAccelSig;
endif  

# perform a least-squares fit to find the 3 parameters for the impulse response model
# the model is h(t) = p3 exp(-p1 t) sin(p2 t)
pin=[10, 26, .1];
stol = .0001;
niter = 50;
fit2rng = [1:length(rollSig)]';
[f,pr,cvg,iter,corp,covpr]=leasqr(fit2rng,rollSig,pin,"hstarRollStim",stol,niter);
if (cvg) disp("roll fit converged"); endif

fit2rng = [1:length(pitchSig)]';
[f,pp,cvg,iter,corp,covpr]=leasqr(fit2rng,pitchSig,pin,"hstarPitchStim",stol,niter);

rollw0 = pr(2);
pitchw0 = pp(2);
rollF0 = rollw0 / 2 / pi;
pitchF0 = pitchw0 / 2 / pi;
rollZeta = pr(1) / rollw0;
pitchZeta = pp(1) / pitchw0;

rollImpFit = pr(3) * decaysin(gfitrng, pr);
pitchImpFit = pp(3) * decaysin(gfitrng, pp);
if (cvg) disp("pitch fit converged"); endif

# compute transfer functions
Nfft = 2048;
TFrollSig = fft(rollImpFit, Nfft);
TFpitchSig = fft(pitchImpFit, Nfft);
freqInt = (1/sampInt) / Nfft;
xRange = [1:20 / freqInt];
fRange = [0:xRange(end)-1] * freqInt;

rLimit = find(arg(TFrollSig)<(-pi/2));
if ((size(rLimit,1)>0) && rLimit(1) < length(fRange)) 
	rLimit = fRange(rLimit(1));
else 
	rLimit = 0; 
endif
pLimit = find(arg(TFpitchSig)<(-pi/2));
if ((size(pLimit,1)>0) && pLimit(1) < length(fRange)) 
	pLimit = fRange(pLimit(1));
else 
	pLimit = 0; 
endif

# load PX4 parameters
load([basePath "/parameters.octave"]);

disp(["test " label " Response"]);

peakImp = max(rollImpFit);
lagRollImp = find(rollImpFit==peakImp)
modelRoll = fftfilt(rollImpFit, grollStim);

grollStimMean = mean(grollStim);
Nlags = 100;
[RrollModel, lag] = xcorr(modelRoll-mean(modelRoll), grollStim-grollStimMean, Nlags);
RrollModel /= max(RrollModel);
lagRoll = findPeakLag(RrollModel, lag)

peakImp = max(pitchImpFit);
lagPitchImp = find(pitchImpFit==peakImp)
modelPitch = fftfilt(pitchImpFit, gpitchStim);

gpitchStimMean = mean(gpitchStim);
[RpitchModel, lag] = xcorr(modelPitch-mean(modelPitch), gpitchStim-gpitchStimMean, Nlags);
RpitchModel /= max(RpitchModel);
lagPitch = findPeakLag(RpitchModel, lag)

dlyRoll = lagRoll * sampInt;
dlyPitch = lagPitch * sampInt;

lagx = sampInt * lag;

figPos = [200,350,512,512];
figure(figNum++, "Position", figPos);
plot( 
	[dlyRoll,dlyRoll],[.8,1],"-b", [dlyPitch,dlyPitch],[.8,1],"-r",
	lagx, RrollModel, "-bo", lagx, RpitchModel, "-ro"
	);
legend("roll", "pitch", "Location", "southeast");
title(sprintf("%s crosscorr. roll lag: %i, pitch lag: %i", label, lagRoll, lagPitch));
axis([0,2*lagPitch*sampInt,.8,1]);
xlabel("seconds");
axis("tight"); grid on;
hgsave([basePath "/" fprefix "crossCorr.ofig"])

disp(sprintf("max rollSig: %5.2f, max roll Stimulus: %5.2f, max modelRoll: %5.2f", max(rollSig), max(grollStim), max(modelRoll)));

varRoll = var(rollSig);
varRollError = var(rollSig - modelRoll);
varRollPred = var(modelRoll);
varPitch = var(pitchSig);
varPitchError = var(pitchSig - modelPitch);
varPitchPred = var(modelPitch);
varFracRoll = 1 - varRollError/varRoll;
varFracPitch = 1 - varPitchError/varPitch;

disp(sprintf("modeled variance:: roll: %5.2f, pitch: %5.2f", varFracRoll, varFracPitch));

figPos = [200,300,1200,512];
figure(figNum++, "Position", figPos);
subplot(2,1,1);
cScale = sum(rollImpFit)
plot(g0tu, modelRoll*rad2deg, g0tu, rollSig*rad2deg, '.-', g0tu+dlyRoll, cScale * grollStim*rad2deg);
legend("modelRoll", "roll", "delayed Control");
axis("tight")
title(sprintf("%s Control, model and actual: roll delay=%4.3f, pitch delay=%4.3f, modeled variance roll %4.2f, pitch %4.2f", label, dlyRoll, dlyPitch, varFracRoll, varFracPitch));
ylabel("degrees/sec");


subplot(2,1,2);
cScale = sum(pitchImpFit)
plot(g0tu, modelPitch*rad2deg, g0tu, pitchSig*rad2deg, '.-', g0tu+dlyPitch, cScale * gpitchStim*rad2deg);
axis("tight")
legend("modelpitch", "pitch", "delayed Control");
ylabel("degrees/sec");
grid on;
%print([basePath "/" fprefix "tracking.png"], "-S1200,512")
hgsave([basePath "/" fprefix "tracking.ofig"])

input("hit return to continue");

figPos = [200,400,1024,900];
figure(figNum++, "Position", figPos);
subplot(3,1,1);
imprng = [0:sampInt:impLen];
ximp = [1:1+impLen/sampInt];
plot(imprng, rollImpFit(ximp), "-b", imprng, pitchImpFit(ximp), "-r");
tLine1 = [label " impulse response --- " sprintf("Roll control latency: %5.3f --- Pitch control latency: %5.3f\n", dlyRoll, dlyPitch)];
      
tLine2 = sprintf(" roll damping: %4.2f, f0: %4.2f Hz, 90deg lag at %4.1f Hz  --- pitch damping: %4.2f, f0: %4.2f Hz, 90deg lag at %4.1f Hz\n",
          rollZeta, rollF0, rLimit, pitchZeta, pitchF0, pLimit);

tLine3 = sprintf(" RollRate P: %5.3f, I: %5.3f, D: %5.4f --- PitchRate P: %5.3f, I: %5.3f, D: %5.4f\n",
      MC_ROLLRATE_P,
      MC_ROLLRATE_I,
      MC_ROLLRATE_D,
      MC_PITCHRATE_P,
      MC_PITCHRATE_I,
      MC_PITCHRATE_D);
      
title([tLine1 tLine2 tLine3]);
legend("roll", "pitch","location","southwest");
legend("boxoff");
xlabel("seconds");
axis("tight"); grid on;

subplot(3,1,2);
semilogx(fRange, 20*log10(abs(TFrollSig(xRange))), "-b", fRange, 20*log10(abs(TFpitchSig(xRange))), "-r",
     [rLimit,rLimit], [-20,20], "-b", [pLimit,pLimit], [-20,20], "-r");
title([label " transfer function magnitude"]);
legend("roll", "pitch","location","southwest");
legend("boxoff");
xlabel("Hz");
ylabel("dB");
axis([0.1 20 -20 10]); grid on;

subplot(3,1,3);
semilogx(fRange, unwrap(arg(TFrollSig(xRange)))*rad2deg, "-b", fRange, unwrap(arg(TFpitchSig(xRange)))*rad2deg, "-r",
     [rLimit,rLimit], [-180,0], "-b", [pLimit,pLimit], [-180,0], "-r");
title([label " transfer function phase"]);
legend("roll", "pitch","location","southwest");
legend("boxoff");
xlabel("Hz"); ylabel("degrees");
axis([0.1 20 -180 0]); grid on;
set(gca, 'YTick', [0 -45 -90 -135 -180])
%print([basePath "/" fprefix "impulse.png"], "-S1200,900")
hgsave([basePath "/" fprefix "impulse.ofig"])

input("hit return to exit");
